# Chat System

## Overview

The chat system provides AI-powered conversational decision support using Claude API. It follows a streaming architecture with real-time token updates, comprehensive error handling, and accessibility features.

**Key Features:**

- Real-time streaming responses via Tauri Channels
- Auto-scroll with smart scroll position detection
- Keyboard shortcuts (Enter, Shift+Enter, Escape)
- Concurrent input handling (queue messages while streaming)
- Full ARIA support for screen readers
- i18n-ready with translation keys

## Architecture

### Component Hierarchy

```
ChatInterface (src/components/chat/ChatInterface.tsx)
├── Error Banner (conditional)
├── ChatMessages (src/components/chat/ChatMessages.tsx)
│   └── ChatBubble[] (src/components/chat/ChatBubble.tsx)
└── ChatInput (src/components/chat/ChatInput.tsx)
```

### State Management

Chat state is managed by **Zustand** store (`src/store/chat-store.ts`) following the selector pattern:

```typescript
interface ChatState {
  // State
  messages: ChatMessage[]
  isStreaming: boolean
  streamingMessageId: string | null
  currentTemplateId: string | null
  configAnswers: Record<string, unknown>
  error: string | null
  queuedMessage: string | null

  // Actions
  addMessage: (message: ChatMessage) => void
  updateStreamingMessage: (id: string, content: string) => void
  completeStreaming: (id: string) => void
  setError: (error: string | null) => void
  setTemplate: (templateId: string | null) => void
  updateConfigAnswer: (key: string, value: unknown) => void
  resetConversation: () => void
  queueMessage: (message: string) => void
  dequeueMessage: () => string | null
}
```

**Pattern enforcement:** ast-grep rules ban Zustand destructuring to prevent render cascades.

```tsx
// ✅ GOOD
const messages = useChatStore(state => state.messages)

// ❌ BAD (banned by ast-grep)
const { messages } = useChatStore()

// ✅ GOOD (in callbacks)
const handleAction = () => {
  const { addMessage } = useChatStore.getState()
  addMessage(newMessage)
}
```

## Message Flow

### 1. User Sends Message

```
User types message in ChatInput
  ↓
handleSendMessage() called
  ↓
addMessage() - Add user message to store
  ↓
addMessage() - Add assistant placeholder (status: 'streaming')
  ↓
Create Tauri Channel for streaming
  ↓
Call commands.sendChatMessage(message, history, systemPrompt, channel)
```

### 2. Streaming Response

```
Rust backend calls Claude API with stream=true
  ↓
Rust parses SSE stream
  ↓
Rust emits StreamEvent::Token via Channel
  ↓
Frontend accumulates tokens
  ↓
updateStreamingMessage() - Update assistant message content
  ↓
ChatMessages re-renders (React Compiler optimizes)
  ↓
Auto-scroll if user near bottom
```

### 3. Stream Complete

```
Rust receives final event from Claude API
  ↓
Rust emits StreamEvent::Done
  ↓
Frontend calls completeStreaming(messageId)
  ↓
Message status → 'complete'
  ↓
Check for queued messages → send if any
```

### 4. Error Handling

```
API error occurs (network, rate limit, timeout)
  ↓
Rust emits StreamEvent::Error { message }
  ↓
Frontend calls setError(message)
  ↓
Error banner shown at top of chat
  ↓
Message status → 'error'
  ↓
User can dismiss error or retry
```

## StreamEvent Types

Defined in `src/lib/bindings.ts` (auto-generated by tauri-specta):

```typescript
export type StreamEvent =
  | { type: 'Token'; content: string }
  | { type: 'Done' }
  | { type: 'Error'; message: string }
```

**Rust definition** (src-tauri/src/commands/chat.rs):

```rust
#[derive(Debug, Clone, Serialize, Deserialize, specta::Type)]
#[serde(tag = "type")]
pub enum StreamEvent {
    Token { content: String },
    Done,
    Error { message: String },
}
```

## Message Types

Two ChatMessage types exist (different purposes):

### 1. Frontend Type (`src/types/chat.ts`)

Used in React components and Zustand store:

```typescript
export interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: number
  status?: 'sending' | 'streaming' | 'complete' | 'error'
  metadata?: Record<string, unknown>
}
```

### 2. Backend API Type (`src/lib/bindings.ts`)

Simplified type for Claude API calls:

```typescript
export type ChatMessage = {
  role: string
  content: string
}
```

**Conversion happens in ChatInterface:**

```typescript
const historyForBackend = messages.map(msg => ({
  role: msg.role,
  content: msg.content,
}))

await commands.sendChatMessage(content, historyForBackend, null, channel)
```

## Auto-scroll Pattern

ChatMessages implements smart auto-scroll to avoid interrupting user reading:

```typescript
// Check if user is near bottom
const isNearBottom = () => {
  if (!scrollAreaRef.current) return true
  const { scrollTop, scrollHeight, clientHeight } = scrollAreaRef.current
  return scrollHeight - scrollTop - clientHeight < 100
}

// Auto-scroll on new messages (only if near bottom)
useEffect(() => {
  if (messages.length > 0 && isNearBottom()) {
    scrollToBottom('smooth')
  } else if (messages.length > 0 && !isNearBottom()) {
    setShowScrollButton(true)
  }
}, [messages])
```

**Behavior:**

- If user is within 100px of bottom: auto-scroll smoothly
- If user scrolled up >100px: show "New messages ↓" button
- User can manually scroll to bottom by clicking button

## Keyboard Shortcuts

Implemented in ChatInput component:

| Shortcut    | Action                                   |
| ----------- | ---------------------------------------- |
| Enter       | Send message                             |
| Shift+Enter | New line in textarea                     |
| Escape      | Clear input (or stop streaming if empty) |
| Cmd/Ctrl+A  | Select all (native textarea behavior)    |

**Implementation:**

```typescript
const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    handleSend()
    return
  }

  if (e.key === 'Escape') {
    e.preventDefault()
    if (input.trim() === '' && isStreaming) {
      onStopStreaming?.()
    } else {
      setInput('')
    }
  }
}
```

## Concurrent Input Handling

Users can type while assistant is streaming. Messages are queued and sent after stream completes.

**Flow:**

1. User starts typing while `isStreaming === true`
2. `handleChange` detects streaming state
3. Message queued in `useChatStore.queuedMessage`
4. Stream completes → `useEffect` detects `isStreaming === false`
5. `dequeueMessage()` retrieves queued message
6. `handleSendMessage()` sends queued message

**Implementation:**

```typescript
// In ChatInput
const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
  setInput(e.target.value)

  if (isStreaming && e.target.value.trim()) {
    const { queueMessage } = useChatStore.getState()
    queueMessage(e.target.value.trim())
  }
}

// In ChatInterface
useEffect(() => {
  if (!isStreaming) {
    const { dequeueMessage } = useChatStore.getState()
    const queuedMsg = dequeueMessage()
    if (queuedMsg) {
      handleSendMessage(queuedMsg)
    }
  }
}, [isStreaming])
```

## Error Handling

### Error Types

Defined in `src/lib/bindings.ts` (from Rust):

```typescript
export type ChatError =
  | { type: 'ConfigError'; message: string }
  | { type: 'RateLimitError'; retry_after: number | null }
  | { type: 'ApiError'; message: string }
  | { type: 'TimeoutError' }
  | { type: 'NetworkError'; message: string }
  | { type: 'ParseError'; message: string }
```

### Error Banner

Shown at top of ChatInterface when `error !== null`:

```tsx
{
  error && (
    <div className="bg-red-50 dark:bg-red-950 border-b border-red-200 dark:border-red-800 px-4 py-2">
      <div className="flex items-center justify-between">
        <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
        <button
          onClick={() => useChatStore.getState().setError(null)}
          aria-label={t('chat.error.dismiss')}
        >
          ✕
        </button>
      </div>
    </div>
  )
}
```

### Error Messages

User-friendly messages via i18n:

```json
{
  "chat.error.rateLimit": "Rate limit exceeded. Please wait a moment and try again.",
  "chat.error.timeout": "Request timed out. Please check your connection and try again.",
  "chat.error.network": "Network error. Please check your connection and try again.",
  "chat.error.generic": "Something went wrong. Please try again."
}
```

### Retry Logic

Exponential backoff handled in Rust backend (src-tauri/src/commands/chat.rs):

```rust
let mut retry_count = 0;
const MAX_RETRIES: u32 = 3;

while retry_count < MAX_RETRIES {
    match send_request(&client, &url, &body).await {
        Ok(response) => return Ok(response),
        Err(e) if e.is_timeout() => {
            retry_count += 1;
            let backoff = Duration::from_secs(2u64.pow(retry_count));
            tokio::time::sleep(backoff).await;
        }
        Err(e) => return Err(e),
    }
}
```

## Accessibility

### ARIA Live Regions

ChatMessages uses `role="log"` with `aria-live="polite"`:

```tsx
<div role="log" aria-live="polite" aria-label={t('chat.messages.ariaLabel')}>
  {messages.map(message => (
    <ChatBubble key={message.id} message={message} />
  ))}
</div>
```

**Why `polite`:** Doesn't interrupt screen reader announcements, but announces new messages when current announcement finishes.

### Input Labels

```tsx
<Textarea
  aria-label={t('chat.input.ariaLabel')}
  placeholder={t('chat.input.placeholder')}
/>

<Button aria-label={t('chat.input.sendButton')}>
  {t('chat.input.send')}
</Button>
```

### Focus Management

Input receives focus after sending message:

```typescript
const handleSend = () => {
  // ... send logic
  setTimeout(() => {
    textareaRef.current?.focus()
  }, 0)
}
```

## Internationalization

All UI strings use i18n keys from `locales/en.json`:

```json
{
  "chat.typing": "Typing",
  "chat.input.placeholder": "Type your message here...",
  "chat.input.send": "Send",
  "chat.empty.title": "Welcome to Unheard",
  "chat.empty.description": "I'm here to help you make better decisions...",
  "chat.error.generic": "Something went wrong. Please try again."
}
```

**Usage in components:**

```tsx
import { useTranslation } from 'react-i18next'

function ChatComponent() {
  const { t } = useTranslation()
  return <h1>{t('chat.empty.title')}</h1>
}
```

## Testing

### Component Tests

Located in `src/components/chat/ChatInterface.test.tsx`:

**Coverage:**

- ChatBubble: User vs assistant styling, streaming indicator, error states
- ChatMessages: Empty state, message rendering order, ARIA live regions
- ChatInput: Keyboard shortcuts, send button state, disabled during streaming
- ChatInterface: Message sending, error banner, queued messages

**Run tests:**

```bash
npm run test src/components/chat/ChatInterface.test.tsx
```

### Test Mocks

```typescript
// Mock Tauri commands
vi.mock('@/lib/bindings', () => ({
  commands: {
    sendChatMessage: vi.fn().mockResolvedValue({
      status: 'ok',
      data: { success: true },
    }),
  },
}))

// Mock Tauri Channel
vi.mock('@tauri-apps/api/core', () => ({
  Channel: class {
    onmessage = null
  },
}))

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}))
```

## Performance

### React Compiler Optimization

React 19's compiler automatically memoizes components. **No manual `useMemo`/`useCallback` needed.**

### Zustand Selector Pattern

Selector syntax ensures components only re-render when their specific slice changes:

```tsx
// Only re-renders when messages change
const messages = useChatStore(state => state.messages)

// Would re-render on ANY store change (bad)
const { messages } = useChatStore()
```

### Debounced Scroll Events

ChatMessages debounces scroll event handling to avoid excessive re-renders:

```tsx
const handleScroll = () => {
  if (isNearBottom()) {
    setShowScrollButton(false)
  } else {
    setShowScrollButton(true)
  }
}
```

## Future Enhancements (Phase 3+)

### Planned Features

1. **Conversation Persistence**: Save conversations to Convex (Phase 4)
2. **Template Configuration Wizard**: Guided multi-step configuration UI
3. **Agent Intent Classification**: Auto-detect decision type from user input
4. **Markdown Rendering**: Code syntax highlighting, LaTeX support
5. **Voice Input**: Speech-to-text integration
6. **Multi-user Conversations**: Collaboration features
7. **Conversation Search**: Full-text search across message history
8. **Export Options**: PDF, Word, Markdown export

### Phase 2 Limitations

- Conversations are **ephemeral** (lost on refresh/close)
- No **conversation history** in sidebar
- No **edit previous message** capability
- No **message retry** button (must type again)
- **English only** (i18n infrastructure ready for Phase 3+)

## Related Documentation

- **UI Patterns**: `docs/developer/ui-patterns.md` (Chat Components section)
- **State Management**: `docs/developer/state-management.md` (Zustand patterns)
- **Tauri Commands**: `docs/developer/tauri-commands.md` (send_chat_message command)
- **Claude SDK Integration**: `docs/developer/claude-sdk-integration.md` (API details)
- **i18n Patterns**: `docs/developer/i18n-patterns.md` (Translation keys)
- **Testing**: `docs/developer/testing.md` (Component testing patterns)
