{
  "created_at": "2026-02-04T14:59:17.787773Z",
  "epic": {
    "data": {
      "branch_name": "fn-2-phase-2-chat-interface-agent",
      "completion_review_status": "unknown",
      "completion_reviewed_at": null,
      "created_at": "2026-02-04T14:54:22.465434Z",
      "default_impl": null,
      "default_review": null,
      "default_sync": null,
      "depends_on_epics": ["fn-1-phase-1-context-upload-git-integration"],
      "id": "fn-2-phase-2-chat-interface-agent",
      "next_task": 1,
      "plan_review_status": "unknown",
      "plan_reviewed_at": null,
      "spec_path": ".flow/specs/fn-2-phase-2-chat-interface-agent.md",
      "status": "open",
      "title": "Phase 2: Chat Interface + Agent",
      "updated_at": "2026-02-04T14:56:07.458968Z"
    },
    "spec": "# Phase 2: Chat Interface + Agent\n\n## Overview\n\nEnable founders to make decisions through conversational AI. Users describe their decision in natural language, and a Claude-powered agent guides them through template selection and configuration, then automatically creates a decision log ready for experimentation.\n\n**Duration**: Weeks 3-4 (14 days, follows Phase 1)\n**Stack**: React 19, Claude SDK (@anthropic-ai/sdk), Zustand v5, TanStack Query, Convex, shadcn/ui components\n\n**Goal**: Conversational decision-making works end-to-end (user describes problem \u2192 agent configures experiment \u2192 decision log created).\n\n## Scope\n\n### In Scope\n\n- **Chat UI**: Claude Desktop-style interface with message bubbles, streaming responses, input area\n- **Claude SDK Integration**: Streaming responses via `.stream()` API with token-by-token rendering\n- **Agent System**: Intent classification, template recommendation, guided configuration wizard\n- **Template Library**: 3 core templates in Convex (Investor Evaluation, Pricing Strategy, Product Roadmap)\n- **Decision Log Generation**: Auto-create markdown in `/decisions/`, Git auto-commit\n- **State Management**: New `useChatStore` (Zustand) for conversation state, TanStack Query for persistence\n- **Context Integration**: Agent accesses uploaded context files from Phase 1\n- **Error Handling**: API failures, rate limits, offline mode, validation errors\n\n### Out of Scope\n\n- Multi-user conversations (future phase)\n- Voice input (future)\n- Advanced markdown rendering (code syntax highlighting, LaTeX) - basic markdown only\n- Template marketplace or custom template builder (Phase 5)\n- Conversation search (future)\n- Export to formats other than markdown (future)\n- Mobile-optimized chat UI (future)\n- Multi-language agent responses (English only for Phase 2)\n\n### Key Assumptions (from Gap Analysis)\n\n1. **API Key Security**: For MVP, API key stored in `.env` (frontend). Rust-based proxy for production in Phase 5.\n2. **Chat Entry**: Chat replaces `MainWindowContent` as primary view (not modal/sidebar)\n3. **Conversation Persistence**: Ephemeral for Phase 2 (Zustand only). Convex persistence in Phase 4.\n4. **Template Count**: 3 templates for MVP (Investor, Pricing, Roadmap). Others in Phase 5.\n5. **Streaming Responses**: Yes, stream token-by-token for better UX\n6. **Context Access**: Agent automatically accesses ALL uploaded context files\n7. **Error Recovery**: \"Try Again\" button inline in chat messages\n8. **Configuration Progress**: No back-button - users confirm each step before proceeding\n\n## Approach\n\n**Architecture Pattern**:\n```\nUser types message in ChatInput\n  \u2193\nuseChatStore adds message (role: user)\n  \u2193\nCall Claude SDK stream API [Rust command for security]\n  \u2193 Tauri command: send_chat_message(message, conversationHistory)\nRust: anthropic.messages.stream({ messages, system: AGENT_PROMPT })\n  \u2193 emit progress via Tauri Channel\nFrontend: Accumulate tokens in useChatStore (streaming state)\n  \u2193\nChatMessages component re-renders with new tokens\n  \u2193\nOn stream complete: Analyze if agent selected template\n  \u2193 If template selected \u2192 show TemplateConfigWizard\nConfiguration flow: Agent asks questions \u2192 user answers \u2192 validate\n  \u2193 All questions answered\nGenerate config object + decision summary\n  \u2193\nCreate markdown file via Tauri command: create_decision_log(config)\n  \u2193 Rust: write to /decisions/, git commit\nUpdate Convex: mutation api.decisions.create(decisionData)\n  \u2193\nAgent: \"Decision log created! View at decisions/2026-02-04-investor-evaluation.md\"\n```\n\n**Key Technical Decisions**:\n\n1. **Chat State**: Zustand store with selector pattern (ast-grep enforced)\n   ```typescript\n   const messages = useChatStore(state => state.messages) // GOOD\n   const { messages } = useChatStore() // BAD - banned\n   ```\n\n2. **Streaming Implementation**: Use Tauri command with Channel for token streaming (no UI freeze)\n   ```rust\n   #[command]\n   async fn send_chat_message(\n       message: String,\n       history: Vec<ChatMessage>,\n       channel: Channel,\n   ) -> Result<ChatResponse>\n   ```\n\n3. **Template Storage**: Templates stored as YAML in Convex `experimentTemplates` table. Agent fetches via `api.templates.list()` query.\n\n4. **Decision Log Format**: Markdown with YAML frontmatter (similar to Obsidian). See data models below.\n\n5. **Error Boundaries**: React error boundaries catch rendering errors. API errors shown inline with retry.\n\n6. **Agent Prompts**: Modular system prompt with 4 sections:\n   - Role definition (decision support assistant)\n   - Available templates (dynamic from Convex)\n   - Conversation guidelines (clarifying questions, validation)\n   - Output format (JSON for tool calls, natural language for chat)\n\n**Reuse Patterns** (from repo-scout):\n\n- **Zustand devtools**: Follow `src/store/ui-store.ts:1-86` pattern\n- **TanStack Query**: Follow `src/services/preferences.ts:1-64` pattern (queryKeys, hooks)\n- **Tauri commands**: Use `tauri-specta` bindings from `src/lib/tauri-bindings.ts`\n- **Git commands**: Extend `git_auto_commit` from Phase 1 for decision logs\n- **Convex mutations**: Follow `convex/schema.ts` patterns with indexes\n\n## Data Model Changes\n\n### Convex Schema Updates\n\n```typescript\n// convex/schema.ts - ADD these tables\n\nexperimentTemplates: defineTable({\n  name: v.string(),\n  slug: v.string(),\n  category: v.string(), // 'investor' | 'pricing' | 'roadmap' | 'hiring' | 'operations'\n  description: v.string(),\n  yamlContent: v.string(), // Full YAML template definition\n  version: v.string(),\n  isPublished: v.boolean(),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index('by_slug', ['slug'])\n  .index('by_category', ['category', 'isPublished']),\n\nconversations: defineTable({\n  clerkUserId: v.string(),\n  projectId: v.id('projects'),\n  messages: v.array(v.object({\n    id: v.string(),\n    role: v.union(v.literal('user'), v.literal('assistant')),\n    content: v.string(),\n    timestamp: v.number(),\n  })),\n  status: v.union(\n    v.literal('active'),\n    v.literal('completed'),\n    v.literal('abandoned')\n  ),\n  relatedDecisionId: v.optional(v.id('decisions')),\n  relatedTemplateId: v.optional(v.id('experimentTemplates')),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index('by_user', ['clerkUserId'])\n  .index('by_project', ['projectId']),\n\ndecisions: defineTable({\n  clerkUserId: v.string(),\n  projectId: v.id('projects'),\n  title: v.string(),\n  category: v.string(),\n  templateId: v.optional(v.id('experimentTemplates')),\n  configData: v.any(), // JSON configuration from template wizard\n  markdownFilePath: v.string(), // Relative path in Git: decisions/2026-02-04-slug.md\n  status: v.union(\n    v.literal('draft'),\n    v.literal('ready'),\n    v.literal('running'),\n    v.literal('completed')\n  ),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index('by_user', ['clerkUserId'])\n  .index('by_project', ['projectId'])\n  .index('by_template', ['templateId']),\n```\n\n### Decision Log Markdown Format\n\n```markdown\n---\nid: dec-2026-02-04-investor-eval\ntitle: Seed Fundraising Decision\ncategory: investor-evaluation\ntemplate: investor-evaluation-v1\nstatus: ready\ncreated: 2026-02-04T14:30:00Z\n---\n\n# Seed Fundraising Decision\n\n## Context\n\nEvaluating investor interest for seed round ($2M raise).\n\n## Configuration\n\n- **Stage**: Seed\n- **Amount**: $2M\n- **Industry**: Developer Tools\n- **Current MRR**: $50K\n- **Pitch Summary**: AI-powered decision support for founders...\n\n## Experiment Plan\n\n- **Personas**: 10 investors (5 Seed VCs, 3 Angels, 2 Strategic)\n- **Generated from**: customers.csv (500 rows), pitch-deck.pdf\n\n## Results\n\n(To be filled after experiment runs)\n\n## Decision\n\n(To be made after reviewing results)\n\n---\nAuto-generated by Unheard v2 | Phase 2\n```\n\n### Zustand Store\n\n```typescript\n// src/store/chat-store.ts - NEW file\n\ninterface ChatMessage {\n  id: string\n  role: 'user' | 'assistant'\n  content: string\n  timestamp: number\n  status?: 'sending' | 'streaming' | 'complete' | 'error'\n}\n\ninterface ChatState {\n  // State\n  messages: ChatMessage[]\n  isStreaming: boolean\n  streamingMessageId: string | null\n  currentTemplateId: string | null\n  configAnswers: Record<string, any>\n  error: string | null\n  \n  // Actions\n  addMessage: (message: ChatMessage) => void\n  updateStreamingMessage: (id: string, content: string) => void\n  completeStreaming: (id: string) => void\n  setError: (error: string | null) => void\n  setTemplate: (templateId: string | null) => void\n  updateConfigAnswer: (key: string, value: any) => void\n  resetConversation: () => void\n}\n\nexport const useChatStore = create<ChatState>()(\n  devtools(\n    (set, get) => ({\n      messages: [],\n      isStreaming: false,\n      streamingMessageId: null,\n      currentTemplateId: null,\n      configAnswers: {},\n      error: null,\n      \n      addMessage: (message) => set((s) => ({\n        messages: [...s.messages, message]\n      })),\n      \n      // ... other actions\n    }),\n    { name: 'chat-store' }\n  )\n)\n```\n\n## Quick commands\n\n```bash\n# Install Claude SDK\nnpm install @anthropic-ai/sdk\n\n# Add Rust dependencies\ncd src-tauri && cargo add reqwest tokio-stream serde_json\n\n# Seed templates to Convex\nnpx convex run seed:templates\n\n# Run chat component tests\nnpm run test src/components/chat/ChatInterface.test.tsx\nnpm run test src/store/chat-store.test.ts\n\n# Test Tauri chat command\ncargo test --lib commands::chat::tests\n\n# Manual smoke test\nnpm run tauri:dev\n# 1. Click \"New Decision\" in UI\n# 2. Type: \"Should I raise seed or bootstrap?\"\n# 3. Verify streaming response appears\n# 4. Select template when offered\n# 5. Answer configuration questions\n# 6. Verify decision log created in /decisions\n# 7. Check Git: git log --oneline (should see auto-commit)\n```\n\n## Acceptance\n\n**Phase 2 Complete When**:\n\n- [ ] Chat UI renders with message list and input area\n- [ ] User can type message and send (Enter key or button)\n- [ ] Claude SDK integrated via Tauri command (API key in env)\n- [ ] Streaming responses render token-by-token (no full-text delay)\n- [ ] Agent analyzes user input and suggests template\n- [ ] Template library displays 3 core templates\n- [ ] User can select template from agent suggestion\n- [ ] Configuration wizard renders questions one-by-one\n- [ ] User answers validated before proceeding to next question\n- [ ] All questions answered \u2192 decision summary generated\n- [ ] Decision log markdown file created in `/decisions`\n- [ ] Git auto-commits decision log (reuses Phase 1 command)\n- [ ] Convex mutation saves decision metadata\n- [ ] Error states: API failure shows \"Try Again\" button\n- [ ] Error states: Rate limit shows clear message with retry countdown\n- [ ] Error states: Network offline shows queued state\n- [ ] Conversation resets with \"New Decision\" button\n- [ ] ast-grep passes (Zustand selectors enforced)\n- [ ] All unit tests pass (>80% coverage for chat logic)\n- [ ] Manual E2E test passes: full flow from greeting to decision log\n- [ ] Documentation: 3 new docs created (see docs-gap-scout findings)\n- [ ] Documentation: 10 docs updated with Phase 2 patterns\n\n**Demo Script** (for stakeholder review):\n```\n1. Open Unheard \u2192 Chat is primary view\n2. Type: \"I need to decide if I should raise seed funding or bootstrap\"\n3. Agent streams response: \"I can help with that...\"\n4. Agent suggests: \"Investor Evaluation template\"\n5. User clicks \"Use This Template\"\n6. Agent asks: \"What stage are you at?\"\n7. User answers: \"Seed, raising $2M\"\n8. Agent asks: \"What's your industry?\"\n9. User answers: \"Developer tools\"\n10. Agent asks: \"Current MRR?\"\n11. User answers: \"$50K\"\n12. Agent asks: \"Summarize your pitch in 2-3 sentences\"\n13. User provides pitch\n14. Agent: \"Great! I've created a decision log and configured an experiment...\"\n15. Check: decision log exists in decisions/ directory\n16. Check: Git log shows auto-commit\n17. Check: Convex dashboard shows new decision entry\nTotal time: <3 minutes\n```\n\n## Risks & Mitigations\n\n| Risk | Impact | Mitigation |\n|------|--------|------------|\n| **Claude API rate limits** | Users blocked mid-conversation | Implement exponential backoff, show retry countdown, cache responses |\n| **API key in frontend** | Security concern for production | Document as MVP limitation, plan Rust proxy for Phase 5 |\n| **Token context overflow** | Long conversations exceed Claude limits | Implement sliding window (keep last 20 messages), summarize older context |\n| **Streaming interruptions** | Partial responses, corrupted state | Implement abort controller, retry logic, partial content recovery |\n| **Template YAML errors** | Agent cannot parse templates | Validate YAML on seed, unit tests for parser, fallback to default template |\n| **Git conflicts** | Concurrent decision log writes | Use unique filenames (timestamp + slug), atomic file writes |\n| **Convex mutation failures** | Decision saved to Git but not cloud | Implement retry queue in localStorage, background sync |\n| **UI freeze during streaming** | Poor UX, app feels slow | Mandatory Tauri Channels, debounced React re-renders |\n| **ast-grep violations** | Destructuring Zustand in new code | Pre-commit hook runs ast-grep, CI gate blocks PRs |\n\n## References\n\n**Existing Patterns**:\n- Zustand store: `src/store/ui-store.ts:1-86`\n- TanStack Query: `src/services/preferences.ts:1-64`\n- Tauri commands: `src-tauri/src/commands/preferences.rs:1-50`\n- Git commands: Phase 1 spec `git_auto_commit` (fn-1, task 5)\n- Error handling: `docs/developer/error-handling.md`\n- State management: `docs/developer/state-management.md`\n\n**External Docs**:\n- [Claude SDK Streaming](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/examples/streaming.ts)\n- [React 19 Hooks](https://react.dev/blog/2024/12/05/react-19)\n- [Zustand v5 Selectors](https://zustand.docs.pmnd.rs/guides/auto-generating-selectors)\n- [Convex Real-time](https://docs.convex.dev/realtime)\n- [Template System Spec](.claude/plans/template-system-spec.md)\n\n**Implementation Plans**:\n- Detailed day-by-day: `.claude/plans/IMPLEMENTATION-PRIORITY.md` lines 266-548\n- Enhanced agent spec: `.claude/plans/enhanced-assistant-spec.md`\n- Data models: `.claude/plans/data-models-spec.md`\n\n## Open Questions\n\n1. **Multi-tab behavior**: If user opens 2 tabs, should conversations sync via Convex real-time or stay independent?\n2. **Template seeding**: Should templates be code-committed or admin-only via Convex dashboard?\n3. **Conversation limits**: Should there be max messages per conversation (e.g., 100) before archival?\n4. **Keyboard shortcuts**: Should Cmd+Enter send message, Escape cancel streaming?\n5. **Context visibility**: Should context files appear in a sidebar during chat, or hidden until agent uses them?\n"
  },
  "epic_id": "fn-2-phase-2-chat-interface-agent",
  "schema_version": 2,
  "tasks": [
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:23.998157Z",
        "depends_on": [],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.1",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.1.md",
        "status": "todo",
        "title": "Zustand chat store + TypeScript types",
        "updated_at": "2026-02-04T14:59:02.743923Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.1",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.1 Zustand chat store + TypeScript types\n\n## Description\nCreate Zustand store for chat state management with TypeScript types following codebase patterns.\n\n**Size:** M\n**Files:**\n- `src/store/chat-store.ts` (new)\n- `src/store/chat-store.test.ts` (new)\n- `src/types/chat.ts` (new)\n\n## Approach\n\nFollow existing Zustand pattern from `src/store/ui-store.ts:1-86`:\n- Use `create<T>()()` with devtools middleware\n- Selector syntax mandatory (ast-grep enforced - no destructuring)\n- Actions use `set()` for state updates\n- Message state includes streaming status\n\n## Key Context\n\n**Streaming State Pattern** (from practice-scout):\n- Track `streamingMessageId` separately from messages array\n- Use `status` field per message: 'sending' | 'streaming' | 'complete' | 'error'\n- `updateStreamingMessage()` accumulates tokens without full re-render\n\n**getState() Pattern** (from architecture guide):\n- Use in callbacks/event handlers to avoid stale closures\n- Example: `const { messages } = useChatStore.getState()`\n\n**Type Safety**:\n- All actions return `void`\n- Messages have required `id`, `role`, `content`, `timestamp`\n- Optional fields: `status`, `metadata`\n\n## References\n\n- Pattern: `src/store/ui-store.ts:1-86`\n- Testing: `src/store/ui-store.test.ts`\n- Architecture: `docs/developer/state-management.md`\n## Acceptance\n- [ ] `useChatStore` created with devtools middleware\n- [ ] Store exports: messages, isStreaming, streamingMessageId, currentTemplateId, configAnswers, error\n- [ ] Actions: addMessage, updateStreamingMessage, completeStreaming, setError, setTemplate, updateConfigAnswer, resetConversation\n- [ ] TypeScript types exported from `src/types/chat.ts`\n- [ ] Types include: ChatMessage, ChatRole, MessageStatus, ChatState\n- [ ] Unit tests cover all actions (>80% coverage)\n- [ ] Test: Adding message appends to array\n- [ ] Test: Updating streaming message replaces content at correct ID\n- [ ] Test: resetConversation clears all state\n- [ ] ast-grep passes (no destructuring in store usage)\n- [ ] Documentation: Update `docs/developer/state-management.md` with chat store example\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.074456Z",
        "depends_on": [],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.2",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.2.md",
        "status": "todo",
        "title": "Claude SDK Tauri streaming command",
        "updated_at": "2026-02-04T14:59:02.821116Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.2",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.2 Claude SDK Tauri streaming command\n\n## Description\nImplement Tauri command that calls Claude SDK with streaming responses via Channel.\n\n**Size:** M\n**Files:**\n- `src-tauri/src/commands/chat.rs` (new)\n- `src-tauri/src/lib.rs` (register command)\n- `src-tauri/Cargo.toml` (add dependencies)\n- `src/lib/tauri-bindings.ts` (update with new command)\n\n## Approach\n\n**Tauri Streaming Pattern** (from architecture guide):\n- Use `tauri::ipc::Channel` for token streaming (no UI freeze)\n- Spawn blocking task for async HTTP calls\n- Emit progress events: `{type: 'token', content: string}`, `{type: 'done'}`, `{type: 'error', message: string}`\n\n**Rust Dependencies**:\n```toml\nreqwest = { version = \"0.12\", features = [\"json\", \"stream\"] }\ntokio-stream = \"0.1\"\nserde_json = \"1.0\"\n```\n\n**API Key Strategy** (from gap analysis):\n- Read from environment variable `ANTHROPIC_API_KEY`\n- Return clear error if missing: \"ANTHROPIC_API_KEY not configured\"\n\n**Follow Pattern**: `src-tauri/src/commands/preferences.rs:1-50`\n\n## Key Context\n\n**Claude SDK Streaming** (from docs-scout):\n- POST to `https://api.anthropic.com/v1/messages`\n- Headers: `anthropic-version: 2023-06-01`, `x-api-key`, `content-type: application/json`\n- Body: `{ model, max_tokens, messages, stream: true, system }`\n- Response: Server-sent events (SSE) stream\n- Event format: `data: {\"type\":\"content_block_delta\",\"delta\":{\"type\":\"text_delta\",\"text\":\"token\"}}`\n\n**Error Handling**:\n- 429 Rate Limit \u2192 return `RateLimitError` with retry-after\n- 500 Server Error \u2192 return `ApiError` with message\n- Timeout (60s) \u2192 return `TimeoutError`\n\n## References\n\n- Tauri Channel: `https://v2.tauri.app/reference/javascript/api/ipc/#channel`\n- Claude API: `https://platform.claude.com/docs/en/api/messages-streaming`\n- Pattern: `src-tauri/src/commands/preferences.rs`\n## Acceptance\n- [ ] Rust command `send_chat_message` accepts: message (String), history (Vec<ChatMessage>), system_prompt (String), channel (Channel)\n- [ ] Command returns `Result<ChatResponse, ChatError>`\n- [ ] Streams tokens via channel as received from API\n- [ ] Emits final `done` event when stream completes\n- [ ] Emits `error` event on API failures\n- [ ] Error types: RateLimitError, ApiError, TimeoutError, ConfigError (missing API key)\n- [ ] Command registered in `lib.rs` and bindings updated via `tauri-specta`\n- [ ] Unit tests: Mock API responses and verify event emission\n- [ ] Test: Valid API key returns streaming tokens\n- [ ] Test: Missing API key returns ConfigError\n- [ ] Test: Rate limit (429) returns RateLimitError with retry-after\n- [ ] Test: Network timeout returns TimeoutError\n- [ ] cargo clippy passes with no warnings\n- [ ] Documentation: Update `docs/developer/tauri-commands.md` with streaming command pattern\n- [ ] Documentation: Create `docs/developer/claude-sdk-integration.md` (new)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.150128Z",
        "depends_on": ["fn-2-phase-2-chat-interface-agent.1"],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.3",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.3.md",
        "status": "todo",
        "title": "Chat UI components (messages, input, bubbles)",
        "updated_at": "2026-02-04T14:59:02.899841Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.3",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.3 Chat UI components (messages, input, bubbles)\n\n## Description\nBuild chat UI components with streaming message rendering and input handling.\n\n**Size:** M\n**Files:**\n- `src/components/chat/ChatInterface.tsx` (new)\n- `src/components/chat/ChatMessages.tsx` (new)\n- `src/components/chat/ChatInput.tsx` (new)\n- `src/components/chat/ChatBubble.tsx` (new)\n- `src/components/chat/ChatInterface.test.tsx` (new)\n\n## Approach\n\n**Component Structure**:\n```\nChatInterface (container)\n\u251c\u2500\u2500 ChatMessages (scroll area with message list)\n\u2502   \u2514\u2500\u2500 ChatBubble (individual message bubble)\n\u2514\u2500\u2500 ChatInput (textarea + send button)\n```\n\n**Reuse shadcn/ui primitives**:\n- `ScrollArea` from `src/components/ui/scroll-area.tsx`\n- `Card` from `src/components/ui/card.tsx` (for message bubbles)\n- `Textarea` from `src/components/ui/textarea.tsx`\n- `Button` from `src/components/ui/button.tsx`\n\n**Streaming Rendering** (from practice-scout):\n- Use `useEffect` to subscribe to streaming channel events\n- Accumulate tokens in local state or directly update useChatStore\n- Auto-scroll to bottom on new messages (with \"scroll to bottom\" button if user scrolled up)\n\n**State Connection** (CRITICAL):\n```typescript\n// GOOD - selector pattern\nconst messages = useChatStore(state => state.messages)\nconst isStreaming = useChatStore(state => state.isStreaming)\n\n// BAD - destructuring (ast-grep will fail)\nconst { messages, isStreaming } = useChatStore()\n```\n\n## Key Context\n\n**Auto-scroll Pattern** (from github-scout):\n- Track scroll position with `useRef`\n- Only auto-scroll if user is near bottom (<100px from bottom)\n- Show \"New messages \u2193\" button if user scrolled up\n\n**Keyboard Shortcuts**:\n- Enter: Send message (if not shift+enter)\n- Shift+Enter: New line\n- Escape: Clear input (if empty) or stop streaming (if streaming)\n\n**Accessibility** (from practice-scout):\n- Add `aria-live=\"polite\"` to message container\n- Role=\"log\" for message list\n- Focus management: Focus input after send\n\n## References\n\n- State pattern: `docs/developer/state-management.md`\n- UI patterns: `docs/developer/ui-patterns.md`\n- Task 1: Types from `src/types/chat.ts`\n## Acceptance\n- [ ] ChatInterface component renders with message list and input\n- [ ] ChatMessages displays messages from useChatStore\n- [ ] ChatBubble styles: user messages (right-aligned, blue), assistant (left-aligned, gray)\n- [ ] Streaming messages show typing indicator (animated dots or cursor)\n- [ ] Auto-scroll to bottom on new messages (unless user scrolled up)\n- [ ] \"Scroll to bottom\" button appears when user scrolls up >100px\n- [ ] ChatInput textarea expands up to 5 lines, then scrolls\n- [ ] Send button disabled when input empty or streaming\n- [ ] Enter key sends message (Shift+Enter for new line)\n- [ ] Escape key clears input or stops streaming\n- [ ] Empty state: Show welcome message when no messages\n- [ ] Component tests: Rendering, user interactions, streaming updates\n- [ ] Test: Messages render in correct order\n- [ ] Test: Streaming message updates in real-time\n- [ ] Test: Send button triggers addMessage action\n- [ ] Test: Enter key sends message\n- [ ] ast-grep passes (Zustand selectors, no destructuring)\n- [ ] Documentation: Update `docs/developer/ui-patterns.md` with chat component patterns\n- [ ] Documentation: Create `docs/developer/chat-system.md` (new)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.225159Z",
        "depends_on": ["fn-2-phase-2-chat-interface-agent.2"],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.4",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.4.md",
        "status": "todo",
        "title": "Template library + agent intent classification",
        "updated_at": "2026-02-04T14:59:02.975114Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.4",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.4 Template library + agent intent classification\n\n## Description\nImplement template library in Convex and agent logic for intent classification and template recommendation.\n\n**Size:** M\n**Files:**\n- `convex/schema.ts` (update)\n- `convex/templates.ts` (new - queries/mutations)\n- `convex/seed-templates.ts` (new - seed function)\n- `src/services/templates.ts` (new - TanStack Query hooks)\n- `src/lib/agent/intent-classifier.ts` (new)\n- `src/lib/agent/system-prompts.ts` (new)\n\n## Approach\n\n**Template Storage**:\n- Convex table `experimentTemplates` with fields: name, slug, category, description, yamlContent, version, isPublished\n- 3 seed templates: investor-evaluation, pricing-strategy, product-roadmap\n- YAML format from `.claude/plans/template-system-spec.md:489-538`\n\n**Template Query Pattern** (from repo-scout):\n```typescript\n// src/services/templates.ts\nexport const templateKeys = {\n  all: ['templates'] as const,\n  list: () => [...templateKeys.all, 'list'] as const,\n  detail: (id: string) => [...templateKeys.all, id] as const,\n}\n\nexport function useTemplates() {\n  return useQuery({\n    queryKey: templateKeys.list(),\n    queryFn: async () => convex.query(api.templates.list),\n    staleTime: 1000 * 60 * 5,\n  })\n}\n```\n\n**Intent Classification**:\n- Analyze user message for keywords (fundraising, pricing, roadmap)\n- Simple keyword matching for MVP (no ML)\n- Return 1-2 template suggestions with confidence scores\n\n**System Prompt** (from enhanced-assistant-spec):\n- Modular prompt: role definition + available templates + guidelines\n- Templates injected dynamically from Convex query\n- Prompt located in `src/lib/agent/system-prompts.ts`\n\n## Key Context\n\n**Convex Real-time** (from docs-scout):\n- `useQuery` auto-subscribes to updates\n- No manual invalidation needed (Convex pushes changes)\n- Pass `\"skip\"` to conditionally skip query (not conditional hook calls)\n\n**Template Seeding**:\n- Run via `npx convex run seed:templates` after deployment\n- Idempotent: Check if templates exist before inserting\n- Log seeded template IDs\n\n## References\n\n- Convex pattern: `src/services/preferences.ts:1-64`\n- Schema: `convex/schema.ts:1-69`\n- Template spec: `.claude/plans/template-system-spec.md`\n- Agent spec: `.claude/plans/enhanced-assistant-spec.md`\n- Task 2: Claude SDK command for agent responses\n## Acceptance\n- [ ] Convex schema updated with `experimentTemplates` table\n- [ ] Indexes: by_slug, by_category (with isPublished filter)\n- [ ] Queries: `list()`, `get(id)`, `getBySlug(slug)`\n- [ ] Mutations: `create(template)`, `update(id, fields)`, `publish(id)`\n- [ ] Seed function creates 3 templates: investor-evaluation, pricing-strategy, product-roadmap\n- [ ] YAML content validates against template spec schema\n- [ ] TanStack Query hooks: `useTemplates()`, `useTemplate(id)`, `useCreateTemplate()`\n- [ ] Intent classifier analyzes message and returns template suggestions\n- [ ] Classifier handles: \"raise funding\" \u2192 investor, \"pricing decision\" \u2192 pricing, \"feature priority\" \u2192 roadmap\n- [ ] System prompt includes all published templates dynamically\n- [ ] System prompt defines agent role, conversation guidelines, output format\n- [ ] Unit tests: Template queries return correct data\n- [ ] Test: Intent classifier matches keywords to templates\n- [ ] Test: System prompt includes template list\n- [ ] Test: Seed function is idempotent (doesn't duplicate)\n- [ ] Convex dev dashboard shows templates after seed\n- [ ] Documentation: Update `docs/developer/convex-setup.md` with template schema\n- [ ] Documentation: Update `docs/developer/data-persistence.md` with template patterns\n- [ ] Documentation: Create `docs/developer/agent-system.md` (new)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.300160Z",
        "depends_on": [
          "fn-2-phase-2-chat-interface-agent.3",
          "fn-2-phase-2-chat-interface-agent.4"
        ],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.5",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.5.md",
        "status": "todo",
        "title": "Template configuration wizard UI",
        "updated_at": "2026-02-04T14:59:03.052030Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.5",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.5 Template configuration wizard UI\n\n## Description\nBuild configuration wizard UI that guides users through template questions with validation.\n\n**Size:** M\n**Files:**\n- `src/components/chat/ConfigWizard.tsx` (new)\n- `src/components/chat/ConfigQuestion.tsx` (new)\n- `src/lib/config-validator.ts` (new)\n- `src/components/chat/ConfigWizard.test.tsx` (new)\n\n## Approach\n\n**Wizard Flow**:\n1. Agent suggests template \u2192 User confirms\n2. Wizard fetches template YAML \u2192 parses questions\n3. Display question 1 \u2192 User answers \u2192 Validate\n4. Display question 2 \u2192 ... \u2192 All answered\n5. Generate config object \u2192 Update useChatStore.configAnswers\n\n**Question Types** (from template spec):\n- `text`: Free-form input (with optional regex validation)\n- `select`: Dropdown or radio buttons\n- `multiselect`: Checkboxes\n- `number`: Numeric input with min/max\n- `boolean`: Yes/No toggle\n\n**Validation Pattern**:\n- Client-side validation before proceeding\n- Show error message inline (below input)\n- Disable \"Next\" button until valid\n- Agent can ask clarifying questions if answer is ambiguous\n\n**State Management**:\n- Use `useChatStore.configAnswers` to persist answers\n- Use `useChatStore.currentTemplateId` to track active template\n\n## Key Context\n\n**YAML Question Format** (from template spec):\n```yaml\nconfiguration_flow:\n  - id: stage\n    type: select\n    question: \"What funding stage are you at?\"\n    options: [\"Seed\", \"Series A\", \"Series B\"]\n    required: true\n\n  - id: amount\n    type: text\n    question: \"How much are you raising?\"\n    validation:\n      pattern: \"^\\\\$[0-9]+(M|K)$\"\n      message: \"Enter amount like $2M or $500K\"\n    required: true\n```\n\n**Conditional Questions** (future, not MVP):\n- Questions can have `depends_on` field\n- Skip if dependency not met\n- Not implemented in Phase 2 (all questions linear)\n\n## References\n\n- Template spec: `.claude/plans/template-system-spec.md:200-350`\n- State: `src/store/chat-store.ts` (Task 1)\n- UI: `src/components/chat/ChatInterface.tsx` (Task 3)\n- Templates: `src/services/templates.ts` (Task 4)\n## Acceptance\n- [ ] ConfigWizard component displays current question\n- [ ] Wizard fetches template from Convex by ID\n- [ ] YAML parser extracts configuration_flow array\n- [ ] Question types rendered correctly: text (input), select (dropdown), number (input type=number), boolean (toggle)\n- [ ] Validation runs on answer change (not on submit)\n- [ ] Error messages shown inline below input\n- [ ] \"Next\" button disabled when invalid or empty (if required)\n- [ ] \"Back\" button not implemented (out of Phase 2 scope - note in open questions)\n- [ ] Progress indicator: \"Question X of Y\"\n- [ ] All questions answered \u2192 \"Review Answers\" summary screen\n- [ ] Summary shows all answers with \"Edit\" links (opens question, not implemented - Phase 5)\n- [ ] \"Confirm\" button generates config object and stores in useChatStore\n- [ ] ConfigQuestion component handles each question type\n- [ ] Validator functions: validateText, validateSelect, validateNumber\n- [ ] Unit tests: Question rendering, validation logic, flow progression\n- [ ] Test: Required text question blocks next until filled\n- [ ] Test: Regex pattern validates correctly\n- [ ] Test: All answered triggers completion\n- [ ] ast-grep passes\n- [ ] Documentation: Update `docs/developer/ui-patterns.md` with wizard pattern\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.375959Z",
        "depends_on": ["fn-2-phase-2-chat-interface-agent.5"],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.6",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.6.md",
        "status": "todo",
        "title": "Decision log markdown generation + Git commit",
        "updated_at": "2026-02-04T14:59:03.128762Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.6",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.6 Decision log markdown generation + Git commit\n\n## Description\nGenerate decision log markdown file from config, commit to Git, and save metadata to Convex.\n\n**Size:** M\n**Files:**\n- `src-tauri/src/commands/decisions.rs` (new)\n- `src/lib/decision-generator.ts` (new - markdown template)\n- `convex/decisions.ts` (new - mutations/queries)\n- `src/services/decisions.ts` (new - TanStack Query hooks)\n\n## Approach\n\n**Flow**:\n1. Config complete \u2192 Call `generateDecisionLog(config, template)`\n2. Generate markdown with YAML frontmatter (see epic spec data model)\n3. Create filename: `YYYY-MM-DD-{slug}.md` (slug from decision title)\n4. Write via Tauri command: `create_decision_log(content, filename)`\n5. Rust: Write to `/decisions`, Git commit (reuse `git_auto_commit` from Phase 1)\n6. Frontend: Save metadata to Convex via `api.decisions.create()`\n7. Return decision ID + file path to frontend\n\n**Filename Generation**:\n- Sanitize title: lowercase, replace spaces with hyphens, remove special chars\n- Prefix with ISO date: `2026-02-04-investor-evaluation.md`\n- Check for duplicates: append `-2` if exists (reuse Phase 1 pattern)\n\n**Markdown Template**:\n```markdown\n---\nid: {generated-id}\ntitle: {user-provided-title}\ncategory: {template-category}\ntemplate: {template-slug}\nstatus: ready\ncreated: {iso-timestamp}\n---\n\n# {Title}\n\n## Context\n{config.context or \"No context provided\"}\n\n## Configuration\n{key-value pairs from config}\n\n## Experiment Plan\n- Personas: {config.persona_count} {config.persona_types}\n- Generated from: {list of context files}\n\n## Results\n(To be filled after experiment runs)\n\n## Decision\n(To be made after reviewing results)\n\n---\nAuto-generated by Unheard v2 | Phase 2\n```\n\n**Reuse Git Command** (from Phase 1):\n- Call existing `git_auto_commit` with files: `[\"decisions/{filename}\"]`\n- Commit message: `\"Create decision: {title}\"`\n\n## Key Context\n\n**Convex Schema** (from epic spec):\n- Table `decisions` with fields: clerkUserId, projectId, title, category, templateId, configData, markdownFilePath, status\n- Status enum: 'draft' | 'ready' | 'running' | 'completed'\n- Indexes: by_user, by_project, by_template\n\n**Error Handling**:\n- If Git commit fails: Log error, save to Convex with status='draft', show warning to user\n- If Convex fails: Retry with exponential backoff (3 attempts), fallback to localStorage queue\n\n## References\n\n- Git command: Phase 1 spec (`fn-1`, task 5) - `git_auto_commit`\n- Markdown format: Epic spec data model section\n- Decision schema: `.claude/plans/data-models-spec.md:150-200`\n- Task 5: Config data from wizard\n## Acceptance\n- [ ] Rust command `create_decision_log` accepts: content (String), filename (String), project_path (PathBuf)\n- [ ] Command writes file to `/decisions/{filename}`\n- [ ] Git commit executed via `git_auto_commit` reuse\n- [ ] Commit message format: \"Create decision: {title}\"\n- [ ] Convex schema includes `decisions` table with required fields\n- [ ] Convex mutation `api.decisions.create` saves metadata\n- [ ] TanStack Query hook `useCreateDecision` wraps mutation\n- [ ] Decision generator creates valid markdown with YAML frontmatter\n- [ ] Filename sanitization: lowercase, hyphens, no special chars\n- [ ] Duplicate handling: append `-2`, `-3` if file exists\n- [ ] Config data serialized to markdown (key-value list)\n- [ ] Context files listed in \"Generated from\" section\n- [ ] Status defaults to 'ready' after creation\n- [ ] Error handling: Git failure \u2192 Convex marked 'draft'\n- [ ] Error handling: Convex failure \u2192 localStorage queue with retry\n- [ ] Unit tests: Markdown generation, filename sanitization, duplicate handling\n- [ ] Test: Valid config produces valid markdown\n- [ ] Test: Duplicate filenames increment correctly\n- [ ] Test: Git failure doesn't break flow\n- [ ] Rust tests: File write, Git commit integration\n- [ ] Documentation: Update `docs/developer/external-apis.md` with decision log pattern\n- [ ] Documentation: Update `docs/userguide/userguide.md` with \"Chat Interface\" section\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-04T14:56:24.451830Z",
        "depends_on": [
          "fn-2-phase-2-chat-interface-agent.3",
          "fn-2-phase-2-chat-interface-agent.4",
          "fn-2-phase-2-chat-interface-agent.6"
        ],
        "epic": "fn-2-phase-2-chat-interface-agent",
        "id": "fn-2-phase-2-chat-interface-agent.7",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-phase-2-chat-interface-agent.7.md",
        "status": "todo",
        "title": "Error handling, retry logic, and polish",
        "updated_at": "2026-02-04T14:59:03.204986Z"
      },
      "id": "fn-2-phase-2-chat-interface-agent.7",
      "runtime": null,
      "spec": "# fn-2-phase-2-chat-interface-agent.7 Error handling, retry logic, and polish\n\n## Description\nImplement comprehensive error handling, retry logic, and UX polish for chat system.\n\n**Size:** M\n**Files:**\n- `src/components/chat/ErrorBoundary.tsx` (new)\n- `src/components/chat/ErrorMessage.tsx` (new)\n- `src/lib/error-handlers.ts` (new)\n- `src/lib/retry-queue.ts` (new - localStorage queue)\n- `src/components/chat/LoadingStates.tsx` (new)\n\n## Approach\n\n**Error Types** (from gap analysis):\n- **API Key Missing**: Show config guide modal\n- **Rate Limit (429)**: Show countdown timer, auto-retry after delay\n- **Network Offline**: Show \"You're offline\" banner, queue messages\n- **API Timeout**: Show \"Try Again\" button inline\n- **Validation Error**: Show field-specific error message\n- **Git/Convex Failure**: Show warning, continue with degraded functionality\n\n**Retry Strategy**:\n- Exponential backoff: 1s, 2s, 4s, 8s, 16s\n- Max 5 retries for transient errors (5xx, network)\n- No retry for permanent errors (4xx except 429, validation)\n- Rate limit: Wait for `retry-after` header duration\n\n**Offline Queue**:\n- Store messages in localStorage when offline\n- On reconnect: Sync queued messages in order\n- Show \"Sending...\" indicator for queued messages\n\n**Loading States**:\n- Streaming: Animated typing indicator (3 dots)\n- Sending: \"Sending...\" text in message bubble\n- Template loading: Skeleton UI for wizard questions\n- Decision saving: \"Creating decision log...\" overlay\n\n**React Error Boundary**:\n- Catch rendering errors in chat components\n- Show friendly \"Something went wrong\" with \"Reset Chat\" button\n- Log error to console (future: send to monitoring)\n\n## Key Context\n\n**Error Display Pattern** (from error-handling.md):\n- Inline errors: Show below input/button (field validation)\n- Toast errors: Non-critical, auto-dismiss (Convex sync failure)\n- Modal errors: Critical, requires action (API key missing)\n- Banner errors: Persistent until resolved (offline mode)\n\n**localStorage Queue Schema**:\n```typescript\ninterface QueuedMessage {\n  id: string\n  message: string\n  timestamp: number\n  retries: number\n  lastError?: string\n}\n```\n\n**Polish Items**:\n- Empty state: \"Start by describing your decision\"\n- Loading skeleton for messages while fetching history\n- Smooth animations: message slide-in, fade-in\n- Focus management: Auto-focus input after send\n- Keyboard shortcuts documented in UI (hover tooltip)\n\n## References\n\n- Error handling: `docs/developer/error-handling.md`\n- Notifications: `src/lib/notifications.ts`\n- Task 3: Chat UI components\n- Task 4: Agent system (error scenarios)\n- Task 6: Decision log (failure modes)\n## Acceptance\n- [ ] React error boundary wraps ChatInterface\n- [ ] Error boundary shows \"Something went wrong\" + \"Reset Chat\" button\n- [ ] ErrorMessage component displays inline errors with \"Try Again\" button\n- [ ] API key missing error shows modal with setup instructions\n- [ ] Rate limit error shows countdown timer and auto-retries after delay\n- [ ] Network offline shows banner: \"You're offline. Messages will send when you reconnect.\"\n- [ ] Offline queue stores messages in localStorage\n- [ ] On reconnect, queued messages sync in order\n- [ ] Retry logic: Exponential backoff with max 5 attempts\n- [ ] Loading states: Typing indicator (animated dots) during streaming\n- [ ] Loading states: \"Sending...\" for outgoing messages\n- [ ] Loading states: Skeleton UI for wizard questions\n- [ ] Loading states: Overlay with \"Creating decision log...\" during save\n- [ ] Empty state: Friendly message when no conversations\n- [ ] Animations: Smooth message slide-in (CSS transitions)\n- [ ] Focus management: Input focused after message sent\n- [ ] Keyboard shortcuts tooltip on input hover\n- [ ] Unit tests: Error handlers, retry logic, queue sync\n- [ ] Test: Rate limit triggers exponential backoff\n- [ ] Test: Offline queue persists across app restarts\n- [ ] Test: Error boundary catches and displays errors\n- [ ] E2E test: Full flow with simulated API failure and recovery\n- [ ] Documentation: Update `docs/developer/error-handling.md` with chat-specific patterns\n- [ ] Documentation: Update `README.md` with Phase 2 features\n- [ ] Documentation: Update `docs/developer/README.md` index with new guides\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    }
  ]
}
